Practice Exercises for Classes (part 1)

Solve each of the practice exercises below. Each problem includes three CodeSkulptor links: one for a template that you should use as a starting point for your solution, one to our solution to the exercise, and one to a tool that automatically checks your solution.

1. For this set of practice exercises, we will walk you through the creation of a ğšƒğš’ğš•ğš class suitable for use in your week five mini-project, Memory. This class will model the logical behavior of cards/tiles used in Memory. Our goal in walking through this design will be to understand the syntactic structure of a Python class in detail as well as the logic that goes into designing a useful class. In Week 6b, we will use this ğšƒğš’ğš•ğš class to re-implement Memory in an object-oriented style. If, at some point, you feel confused, you may also want to watch this video on the Basics of OOP by Julie. Many students in previous sessions found it to be helpful.

To begin, your first task is to define a ğšƒğš’ğš•ğš class using two lines of Python. For now, the body of this class should just be a single ğš™ğšŠğšœğšœ statement to keep Python from throwing an error. As usual in Python, the body of the class definition should be indented. Definition of ğšƒğš’ğš•ğš class template --- Definition of ğšƒğš’ğš•ğš class solution --- Definition of ğšƒğš’ğš•ğš class (Checker)

2. Your next task is to create two instances (versions) of a ğšƒğš’ğš•ğš object. Note this is possible even though the body of the class definition is currently empty. Of course, the objects that you create at this point will contain no data. We'll add some data to ğšƒğš’ğš•ğš objects in the next problem. Remember that to create an instance of a class ğ™²ğš•ğšŠğšœğšœğ™½ğšŠğš–ğš , you can use the expression ğ™²ğš•ğšŠğšœğšœğ™½ğšŠğš–ğš(). Create a ğšƒğš’ğš•ğš object template --- Create a ğšƒğš’ğš•ğš object solution --- Create a ğšƒğš’ğš•ğš object (Checker)

3. As we noted in the last problem, our current definition of the ğšƒğš’ğš•ğš class produces objects that contain no data. This design is not going to be much help in re-implementing Memory. At this point, we should start considering what kind of data a ğšƒğš’ğš•ğš object should contain. One piece of data that ğšƒğš’ğš•ğš objects should certainly contain is the number associated with the tile. To create a ğšƒğš’ğš•ğš object that contains the number associated with the tile, we need to define a special function known as an initializer in the body of the class definition. (Functions defined in the body of the class definition are referred to as methods.)

In Python, the class initializer always has the special name __ğš’ğš—ğš’ğš__. The parameters to this function __ğš’ğš—ğš’ğš__ provide the information necessary to create the data stored in the object. By convention, the first parameter to __ğš’ğš—ğš’ğš__ has the name ğšœğšğš•ğš and serves as a reference to the object generated by the initializer. The remaining parameters, if any, contain the information used in creating the object. The body of the initializer consists of sequence of Python statements that use this information to compute and add data to the object. Each piece of data stored in the object is named by a field. If name of a field is ğšğš’ğšğš•ğš_ğš—ğšŠğš–ğš, we can reference this piece of data via the expression ğšœğšğš•ğš.ğšğš’ğšğš•ğš_ğš—ğšŠğš–ğš.

Your next task is to implement an initializer for the ğšƒğš’ğš•ğš class and create two tiles; one called ğš–ğš¢_ğšğš’ğš•ğš whose ğš—ğšğš–ğš‹ğšğš› field has the value ğŸ¹ and another called ğš¢ğš˜ğšğš›_ğšğš’ğš•ğš whose number field has value ğŸº. The definition of the initializer should include the required parameter ğšœğšğš•ğš and a parameter ğš—ğšğš– that is the number associated with the tile. The body of the initializer should store ğš—ğšğš– in the field ğš—ğšğš–ğš‹ğšğš›. To create a ğšƒğš’ğš•ğš object, you will need to include the number associated with the tile as parameter when you call ğšƒğš’ğš•ğš(....) to create a ğšƒğš’ğš•ğš object. (The reference corresponding to the parameter ğšœğšğš•ğš is generated by Python during the creation of the ğšƒğš’ğš•ğš object and is not included in the call to the initializer.) Initializer for ğšƒğš’ğš•ğš class template --- Initializer for ğšƒğš’ğš•ğš class solution --- Initializer for ğšƒğš’ğš•ğš class (Checker)

4. In the previous problem, we accessed the one piece of data in the ğšƒğš’ğš•ğš object ğš–ğš¢_ğšğš’ğš•ğš via the expression ğš–ğš¢_ğšğš’ğš•ğš.ğš—ğšğš–ğš‹ğšğš› in the provided testing code. More generally, given an object ğš–ğš¢_ğš˜ğš‹ğš“ğšğšŒğš, Python can access the contents of the field ğšğš’ğšğš•ğš_ğš—ğšŠğš–ğš via the expression ğš–ğš¢_ğš˜ğš‹ğš“ğšğšŒğš.ğšğš’ğšğš•ğš_ğš—ğšŠğš–ğš. In the Python community, accessing the content of an object using its field names is common practice. In this class, we will follow the practice of accessing the contents of objects using methods known as getters and setters. While not required by Python, this practice encourages the user of the class to manipulates class objects solely via class methods. The advantage of following this practice is that the implementer of the class definition (often someone other than the user of the class) may restructure the organization of the data fields associated with the object while avoiding the need to rewrite code that uses the class.

For this problem, your task is to implement a method ğšğšğš_ğš—ğšğš–ğš‹ğšğš› that returns the number associated with a tile. As usual, the first parameter for this method will be ğšœğšğš•ğš. Then, call this method on the ğšƒğš’ğš•ğš object ğš–ğš¢_ğšğš’ğš•ğš and assign this value to the variable ğšğš’ğš•ğš_ğš—ğšğš–ğš‹ğšğš›. Following the convention of other object-oriented programming languages, Python's syntax for calling methods on class objects is ğš˜ğš‹ğš“ğšğšŒğš_ğš—ğšŠğš–ğš.ğš–ğšğšğš‘ğš˜ğš_ğš—ğšŠğš–ğš(....). In evaluating this call, ğš˜ğš‹ğš“ğšğšŒğš_ğš—ğšŠğš–ğš is bound to the first parameter ğšœğšğš•ğš in the definition of ğš–ğšğšğš‘ğš˜ğš_ğš—ğšŠğš–ğš. Note that we have already seen this syntax when calling list methods in Python. For example, the statement ğš–ğš¢_ğš•ğš’ğšœğš.ğšŠğš™ğš™ğšğš—ğš(ğŸ») appends the number ğŸ» to the end of the list ğš–ğš¢_ğš•ğš’ğšœğš. Example method for the ğšƒğš’ğš•ğš class template ---- Example method for the ğšƒğš’ğš•ğš class solution --- Example method for the ğšƒğš’ğš•ğš class (Checker)

5. At this point, our ğšƒğš’ğš•ğš class is still not so useful. Your next task is to add a field called ğšğš¡ğš™ğš˜ğšœğšğš to a ğšƒğš’ğš•ğš class definition and implement three methods that manipulate this field. Logically, this field will be ğšƒğš›ğšğš when the tile's number is exposed to the player and ğ™µğšŠğš•ğšœğš when the tile's number is hidden from the player. To add this field to a ğšƒğš’ğš•ğš object, you will need to add another parameter ğšğš¡ğš™ to the __ğš’ğš—ğš’ğš__ method and initialize the ğšğš¡ğš™ğš˜ğšœğšğš field with this value. Once you have done this, implement three methods described below that manipulate this field. You will use all of these methods when we re-implement Memory.

ğš’ğšœ_ğšğš¡ğš™ğš˜ğšœğšğš which takes a tile and returns the value of the ğšğš¡ğš™ğš˜ğšœğšğš field,
ğšğš¡ğš™ğš˜ğšœğš_ğšğš’ğš•ğš which takes a tile and sets the value of its ğšğš¡ğš™ğš˜ğšœğšğš field to be ğšƒğš›ğšğš, and
ğš‘ğš’ğšğš_ğšğš’ğš•ğš which take a tile and set the value of its ğšğš¡ğš™ğš˜ğšœğšğš field to be ğ™µğšŠğš•ğšœğš.
Note how this design of the ğšƒğš’ğš•ğš class logically binds together the data associated with a tile into a single object. In our previous implementation of Memory, the data associated with a single tile was stored in two separate lists. This design required us to keep track of where the data for the same object was in both lists. For Memory, this task wasn't so hard. However, as the complexity of your programs increase, grouping all of the data corresponding to a single logical entity together is a powerful way to reduce the complexity of your program. Methods for exposing and hiding a ğšƒğš’ğš•ğš object template --- Methods for exposing and hiding a ğšƒğš’ğš•ğš object solution --- Methods for exposing and hiding a ğšƒğš’ğš•ğš object (Checker)

6. In the previous problem, we used the method ğš’ğšœ_ğšğš¡ğš™ğš˜ğšœğšğš to determine whether a tile's number was exposed. Sometimes, especially during debugging, it is useful to know the value of all of the object data fields. As the first few exercises showed, trying to print a ğšƒğš’ğš•ğš object in Python yields a message of the form "<__ğš–ğšŠğš’ğš—__.ğšƒğš’ğš•ğš ğš˜ğš‹ğš“ğšğšŒğš>" This message indicates the object is a tile, but doesn't provide any helpful information about the data stored in the object. In Python, we can define a special string method named __ğšœğšğš›__ that Python will automatically call when printing an object or converting the object into a string. Based on the values of the object's fields, the body of the __ğšœğšğš›__ method should construct and return a string that indicates the state of the object.

For this problem, implement a string method for the ğšƒğš’ğš•ğš class that return a string of the form "ğ™½ğšğš–ğš‹ğšğš› ğš’ğšœ ğŸ¹, ğšğš¡ğš™ğš˜ğšœğšğš ğš’ğšœ ğšƒğš›ğšğš". Remember that you will need to use the ğšœğšğš› operation to convert the data in an object into a string. __str__ method for ğšƒğš’ğš•ğš class template --- __str__ method for ğšƒğš’ğš•ğš class solution --- __str__ method for ğšƒğš’ğš•ğš class (Checker)

7. Challenge: At this point, our ğšƒğš’ğš•ğš class has captured much of the behavior of tiles in Memory. However, the problem of how to draw tiles still remains. One possibility would be to maintain a list of ğšƒğš’ğš•ğš objects and draw them using a for-loop where the location of the tile varies as function of the loop's iteration as done in our suggestion implementation of Memory for week five. This choice, while not terrible, implicitly models the location of a tile by its position in a list. Instead, we suggest that the we store the location of the tile as part of the data associated with a ğšƒğš’ğš•ğš object. This choice groups all of the relevant properties of a tile into one object. Following the convention of ğšğš›ğšŠğš _ğšğšğš¡ğš, the tile's location will be specified by the lower left corner of the tile with the width and height of the tile being specified by the global constants ğšƒğ™¸ğ™»ğ™´_ğš†ğ™¸ğ™³ğšƒğ™· and ğšƒğ™¸ğ™»ğ™´_ğ™·ğ™´ğ™¸ğ™¶ğ™·ğšƒ, respectively.

With this design, we can implement a ğšğš›ğšŠğš _ğšğš’ğš•ğš method for the ğšƒğš’ğš•ğš class that draws the specified tile object at its corresponding location. This ğšğš›ğšŠğš _ğšğš’ğš•ğš method will use SimpleGUI's ğšğš›ğšŠğš _ğšğšğš¡ğš or ğšğš›ğšŠğš _ğš™ğš˜ğš•ğš¢ğšğš˜ğš— methods to draw the tile. Since both of these methods require the canvas which itself is passed to the draw handler, we must call the ğšğš›ğšŠğš _ğšğš’ğš•ğš method inside the draw handler and pass the current canvas as a parameter to ğšğš›ğšŠğš _ğšğš’ğš•ğš. This design moves most of the complexity of drawing a tile out of the draw handler into the ğšƒğš’ğš•ğš class and makes the logic of the draw handler much more transparent.

For this problem, your task is to add the location of the tile to the ğšƒğš’ğš•ğš class and implement a ğšğš›ğšŠğš _ğšğš’ğš•ğš method for the Tile class. The tile should display the tile's number as text at the tile's location if the tile's number is exposed. Otherwise, it should draw the unexposed tile at the its location as a green polygon. If your implementation of the ğšğš›ğšŠğš _ğšğš’ğš•ğš method is correct, our implementation of the draw handler should display a pair of tiles on the canvas, one whose number is exposed and one whose number is not. draw_tile method for the ğšƒğš’ğš•ğš class template --- draw_tile method for the ğšƒğš’ğš•ğš class solution --- draw_tile method for the ğšƒğš’ğš•ğš class (Checker)

8. Challenge: To complete our implementation of the ğšƒğš’ğš•ğš class, we must determine whether a tile has been clicked. In our week five implementation of Memory, this computation was done in the draw handler. For our object-oriented version, we will implement a method ğš’ğšœ_ğšœğšğš•ğšğšŒğšğšğš for the ğšƒğš’ğš•ğš class that returns ğšƒğš›ğšğš if a tile contains a specified point. To determine if a tile has been clicked, the mouse handler will then simply call ğš’ğšœ_ğšœğšğš•ğšğšŒğšğšğš using the position of the mouse. Again, this design moves the determination of whether a point lies on a tile out of the mouse handler into the ğšƒğš’ğš•ğš class, reducing the complexity of the mouse handler.

For the final problem, your task is to implement the ğš’ğšœ_ğšœğšğš•ğšğšŒğšğšğš method. This method take a point ğš™ğš˜ğšœ as a parameter and return ğšƒğš›ğšğš if the point lies inside the tile. If your implementation of this method is correct, our provided template will allow you to flip over two cards whose numbers are hidden. is_selected method for ğšƒğš’ğš•ğš class template --- is_selected method for ğšƒğš’ğš•ğš class solution --- is_selected method for ğšƒğš’ğš•ğš class (Checker)

