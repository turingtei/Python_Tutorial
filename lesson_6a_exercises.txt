Practice Exercises for Classes (part 1)

Solve each of the practice exercises below. Each problem includes three CodeSkulptor links: one for a template that you should use as a starting point for your solution, one to our solution to the exercise, and one to a tool that automatically checks your solution.

1. For this set of practice exercises, we will walk you through the creation of a 𝚃𝚒𝚕𝚎 class suitable for use in your week five mini-project, Memory. This class will model the logical behavior of cards/tiles used in Memory. Our goal in walking through this design will be to understand the syntactic structure of a Python class in detail as well as the logic that goes into designing a useful class. In Week 6b, we will use this 𝚃𝚒𝚕𝚎 class to re-implement Memory in an object-oriented style. If, at some point, you feel confused, you may also want to watch this video on the Basics of OOP by Julie. Many students in previous sessions found it to be helpful.

To begin, your first task is to define a 𝚃𝚒𝚕𝚎 class using two lines of Python. For now, the body of this class should just be a single 𝚙𝚊𝚜𝚜 statement to keep Python from throwing an error. As usual in Python, the body of the class definition should be indented. Definition of 𝚃𝚒𝚕𝚎 class template --- Definition of 𝚃𝚒𝚕𝚎 class solution --- Definition of 𝚃𝚒𝚕𝚎 class (Checker)

2. Your next task is to create two instances (versions) of a 𝚃𝚒𝚕𝚎 object. Note this is possible even though the body of the class definition is currently empty. Of course, the objects that you create at this point will contain no data. We'll add some data to 𝚃𝚒𝚕𝚎 objects in the next problem. Remember that to create an instance of a class 𝙲𝚕𝚊𝚜𝚜𝙽𝚊𝚖𝚎 , you can use the expression 𝙲𝚕𝚊𝚜𝚜𝙽𝚊𝚖𝚎(). Create a 𝚃𝚒𝚕𝚎 object template --- Create a 𝚃𝚒𝚕𝚎 object solution --- Create a 𝚃𝚒𝚕𝚎 object (Checker)

3. As we noted in the last problem, our current definition of the 𝚃𝚒𝚕𝚎 class produces objects that contain no data. This design is not going to be much help in re-implementing Memory. At this point, we should start considering what kind of data a 𝚃𝚒𝚕𝚎 object should contain. One piece of data that 𝚃𝚒𝚕𝚎 objects should certainly contain is the number associated with the tile. To create a 𝚃𝚒𝚕𝚎 object that contains the number associated with the tile, we need to define a special function known as an initializer in the body of the class definition. (Functions defined in the body of the class definition are referred to as methods.)

In Python, the class initializer always has the special name __𝚒𝚗𝚒𝚝__. The parameters to this function __𝚒𝚗𝚒𝚝__ provide the information necessary to create the data stored in the object. By convention, the first parameter to __𝚒𝚗𝚒𝚝__ has the name 𝚜𝚎𝚕𝚏 and serves as a reference to the object generated by the initializer. The remaining parameters, if any, contain the information used in creating the object. The body of the initializer consists of sequence of Python statements that use this information to compute and add data to the object. Each piece of data stored in the object is named by a field. If name of a field is 𝚏𝚒𝚎𝚕𝚍_𝚗𝚊𝚖𝚎, we can reference this piece of data via the expression 𝚜𝚎𝚕𝚏.𝚏𝚒𝚎𝚕𝚍_𝚗𝚊𝚖𝚎.

Your next task is to implement an initializer for the 𝚃𝚒𝚕𝚎 class and create two tiles; one called 𝚖𝚢_𝚝𝚒𝚕𝚎 whose 𝚗𝚞𝚖𝚋𝚎𝚛 field has the value 𝟹 and another called 𝚢𝚘𝚞𝚛_𝚝𝚒𝚕𝚎 whose number field has value 𝟺. The definition of the initializer should include the required parameter 𝚜𝚎𝚕𝚏 and a parameter 𝚗𝚞𝚖 that is the number associated with the tile. The body of the initializer should store 𝚗𝚞𝚖 in the field 𝚗𝚞𝚖𝚋𝚎𝚛. To create a 𝚃𝚒𝚕𝚎 object, you will need to include the number associated with the tile as parameter when you call 𝚃𝚒𝚕𝚎(....) to create a 𝚃𝚒𝚕𝚎 object. (The reference corresponding to the parameter 𝚜𝚎𝚕𝚏 is generated by Python during the creation of the 𝚃𝚒𝚕𝚎 object and is not included in the call to the initializer.) Initializer for 𝚃𝚒𝚕𝚎 class template --- Initializer for 𝚃𝚒𝚕𝚎 class solution --- Initializer for 𝚃𝚒𝚕𝚎 class (Checker)

4. In the previous problem, we accessed the one piece of data in the 𝚃𝚒𝚕𝚎 object 𝚖𝚢_𝚝𝚒𝚕𝚎 via the expression 𝚖𝚢_𝚝𝚒𝚕𝚎.𝚗𝚞𝚖𝚋𝚎𝚛 in the provided testing code. More generally, given an object 𝚖𝚢_𝚘𝚋𝚓𝚎𝚌𝚝, Python can access the contents of the field 𝚏𝚒𝚎𝚕𝚍_𝚗𝚊𝚖𝚎 via the expression 𝚖𝚢_𝚘𝚋𝚓𝚎𝚌𝚝.𝚏𝚒𝚎𝚕𝚍_𝚗𝚊𝚖𝚎. In the Python community, accessing the content of an object using its field names is common practice. In this class, we will follow the practice of accessing the contents of objects using methods known as getters and setters. While not required by Python, this practice encourages the user of the class to manipulates class objects solely via class methods. The advantage of following this practice is that the implementer of the class definition (often someone other than the user of the class) may restructure the organization of the data fields associated with the object while avoiding the need to rewrite code that uses the class.

For this problem, your task is to implement a method 𝚐𝚎𝚝_𝚗𝚞𝚖𝚋𝚎𝚛 that returns the number associated with a tile. As usual, the first parameter for this method will be 𝚜𝚎𝚕𝚏. Then, call this method on the 𝚃𝚒𝚕𝚎 object 𝚖𝚢_𝚝𝚒𝚕𝚎 and assign this value to the variable 𝚝𝚒𝚕𝚎_𝚗𝚞𝚖𝚋𝚎𝚛. Following the convention of other object-oriented programming languages, Python's syntax for calling methods on class objects is 𝚘𝚋𝚓𝚎𝚌𝚝_𝚗𝚊𝚖𝚎.𝚖𝚎𝚝𝚑𝚘𝚍_𝚗𝚊𝚖𝚎(....). In evaluating this call, 𝚘𝚋𝚓𝚎𝚌𝚝_𝚗𝚊𝚖𝚎 is bound to the first parameter 𝚜𝚎𝚕𝚏 in the definition of 𝚖𝚎𝚝𝚑𝚘𝚍_𝚗𝚊𝚖𝚎. Note that we have already seen this syntax when calling list methods in Python. For example, the statement 𝚖𝚢_𝚕𝚒𝚜𝚝.𝚊𝚙𝚙𝚎𝚗𝚍(𝟻) appends the number 𝟻 to the end of the list 𝚖𝚢_𝚕𝚒𝚜𝚝. Example method for the 𝚃𝚒𝚕𝚎 class template ---- Example method for the 𝚃𝚒𝚕𝚎 class solution --- Example method for the 𝚃𝚒𝚕𝚎 class (Checker)

5. At this point, our 𝚃𝚒𝚕𝚎 class is still not so useful. Your next task is to add a field called 𝚎𝚡𝚙𝚘𝚜𝚎𝚍 to a 𝚃𝚒𝚕𝚎 class definition and implement three methods that manipulate this field. Logically, this field will be 𝚃𝚛𝚞𝚎 when the tile's number is exposed to the player and 𝙵𝚊𝚕𝚜𝚎 when the tile's number is hidden from the player. To add this field to a 𝚃𝚒𝚕𝚎 object, you will need to add another parameter 𝚎𝚡𝚙 to the __𝚒𝚗𝚒𝚝__ method and initialize the 𝚎𝚡𝚙𝚘𝚜𝚎𝚍 field with this value. Once you have done this, implement three methods described below that manipulate this field. You will use all of these methods when we re-implement Memory.

𝚒𝚜_𝚎𝚡𝚙𝚘𝚜𝚎𝚍 which takes a tile and returns the value of the 𝚎𝚡𝚙𝚘𝚜𝚎𝚍 field,
𝚎𝚡𝚙𝚘𝚜𝚎_𝚝𝚒𝚕𝚎 which takes a tile and sets the value of its 𝚎𝚡𝚙𝚘𝚜𝚎𝚍 field to be 𝚃𝚛𝚞𝚎, and
𝚑𝚒𝚍𝚎_𝚝𝚒𝚕𝚎 which take a tile and set the value of its 𝚎𝚡𝚙𝚘𝚜𝚎𝚍 field to be 𝙵𝚊𝚕𝚜𝚎.
Note how this design of the 𝚃𝚒𝚕𝚎 class logically binds together the data associated with a tile into a single object. In our previous implementation of Memory, the data associated with a single tile was stored in two separate lists. This design required us to keep track of where the data for the same object was in both lists. For Memory, this task wasn't so hard. However, as the complexity of your programs increase, grouping all of the data corresponding to a single logical entity together is a powerful way to reduce the complexity of your program. Methods for exposing and hiding a 𝚃𝚒𝚕𝚎 object template --- Methods for exposing and hiding a 𝚃𝚒𝚕𝚎 object solution --- Methods for exposing and hiding a 𝚃𝚒𝚕𝚎 object (Checker)

6. In the previous problem, we used the method 𝚒𝚜_𝚎𝚡𝚙𝚘𝚜𝚎𝚍 to determine whether a tile's number was exposed. Sometimes, especially during debugging, it is useful to know the value of all of the object data fields. As the first few exercises showed, trying to print a 𝚃𝚒𝚕𝚎 object in Python yields a message of the form "<__𝚖𝚊𝚒𝚗__.𝚃𝚒𝚕𝚎 𝚘𝚋𝚓𝚎𝚌𝚝>" This message indicates the object is a tile, but doesn't provide any helpful information about the data stored in the object. In Python, we can define a special string method named __𝚜𝚝𝚛__ that Python will automatically call when printing an object or converting the object into a string. Based on the values of the object's fields, the body of the __𝚜𝚝𝚛__ method should construct and return a string that indicates the state of the object.

For this problem, implement a string method for the 𝚃𝚒𝚕𝚎 class that return a string of the form "𝙽𝚞𝚖𝚋𝚎𝚛 𝚒𝚜 𝟹, 𝚎𝚡𝚙𝚘𝚜𝚎𝚍 𝚒𝚜 𝚃𝚛𝚞𝚎". Remember that you will need to use the 𝚜𝚝𝚛 operation to convert the data in an object into a string. __str__ method for 𝚃𝚒𝚕𝚎 class template --- __str__ method for 𝚃𝚒𝚕𝚎 class solution --- __str__ method for 𝚃𝚒𝚕𝚎 class (Checker)

7. Challenge: At this point, our 𝚃𝚒𝚕𝚎 class has captured much of the behavior of tiles in Memory. However, the problem of how to draw tiles still remains. One possibility would be to maintain a list of 𝚃𝚒𝚕𝚎 objects and draw them using a for-loop where the location of the tile varies as function of the loop's iteration as done in our suggestion implementation of Memory for week five. This choice, while not terrible, implicitly models the location of a tile by its position in a list. Instead, we suggest that the we store the location of the tile as part of the data associated with a 𝚃𝚒𝚕𝚎 object. This choice groups all of the relevant properties of a tile into one object. Following the convention of 𝚍𝚛𝚊𝚠_𝚝𝚎𝚡𝚝, the tile's location will be specified by the lower left corner of the tile with the width and height of the tile being specified by the global constants 𝚃𝙸𝙻𝙴_𝚆𝙸𝙳𝚃𝙷 and 𝚃𝙸𝙻𝙴_𝙷𝙴𝙸𝙶𝙷𝚃, respectively.

With this design, we can implement a 𝚍𝚛𝚊𝚠_𝚝𝚒𝚕𝚎 method for the 𝚃𝚒𝚕𝚎 class that draws the specified tile object at its corresponding location. This 𝚍𝚛𝚊𝚠_𝚝𝚒𝚕𝚎 method will use SimpleGUI's 𝚍𝚛𝚊𝚠_𝚝𝚎𝚡𝚝 or 𝚍𝚛𝚊𝚠_𝚙𝚘𝚕𝚢𝚐𝚘𝚗 methods to draw the tile. Since both of these methods require the canvas which itself is passed to the draw handler, we must call the 𝚍𝚛𝚊𝚠_𝚝𝚒𝚕𝚎 method inside the draw handler and pass the current canvas as a parameter to 𝚍𝚛𝚊𝚠_𝚝𝚒𝚕𝚎. This design moves most of the complexity of drawing a tile out of the draw handler into the 𝚃𝚒𝚕𝚎 class and makes the logic of the draw handler much more transparent.

For this problem, your task is to add the location of the tile to the 𝚃𝚒𝚕𝚎 class and implement a 𝚍𝚛𝚊𝚠_𝚝𝚒𝚕𝚎 method for the Tile class. The tile should display the tile's number as text at the tile's location if the tile's number is exposed. Otherwise, it should draw the unexposed tile at the its location as a green polygon. If your implementation of the 𝚍𝚛𝚊𝚠_𝚝𝚒𝚕𝚎 method is correct, our implementation of the draw handler should display a pair of tiles on the canvas, one whose number is exposed and one whose number is not. draw_tile method for the 𝚃𝚒𝚕𝚎 class template --- draw_tile method for the 𝚃𝚒𝚕𝚎 class solution --- draw_tile method for the 𝚃𝚒𝚕𝚎 class (Checker)

8. Challenge: To complete our implementation of the 𝚃𝚒𝚕𝚎 class, we must determine whether a tile has been clicked. In our week five implementation of Memory, this computation was done in the draw handler. For our object-oriented version, we will implement a method 𝚒𝚜_𝚜𝚎𝚕𝚎𝚌𝚝𝚎𝚍 for the 𝚃𝚒𝚕𝚎 class that returns 𝚃𝚛𝚞𝚎 if a tile contains a specified point. To determine if a tile has been clicked, the mouse handler will then simply call 𝚒𝚜_𝚜𝚎𝚕𝚎𝚌𝚝𝚎𝚍 using the position of the mouse. Again, this design moves the determination of whether a point lies on a tile out of the mouse handler into the 𝚃𝚒𝚕𝚎 class, reducing the complexity of the mouse handler.

For the final problem, your task is to implement the 𝚒𝚜_𝚜𝚎𝚕𝚎𝚌𝚝𝚎𝚍 method. This method take a point 𝚙𝚘𝚜 as a parameter and return 𝚃𝚛𝚞𝚎 if the point lies inside the tile. If your implementation of this method is correct, our provided template will allow you to flip over two cards whose numbers are hidden. is_selected method for 𝚃𝚒𝚕𝚎 class template --- is_selected method for 𝚃𝚒𝚕𝚎 class solution --- is_selected method for 𝚃𝚒𝚕𝚎 class (Checker)

